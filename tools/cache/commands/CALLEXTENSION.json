{"parse":{"title":"callExtension","pageid":11718,"parsetree":{"*":"<root><template><title>Command</title><part><name>Comments</name>=<value>\n____________________________________________________________________________________________\n\n</value></part><part><name index=\"1\"/><value> arma2oa </value></part><part><name>Game name</name>=<value>\n\n</value></part><part><name index=\"2\"/><value>1.60</value></part><part><name/>=<value> Game version\n\n</value></part><part><name>gr1</name>=<value> System </value></part><part><name>GROUP1</name>=<value>\n____________________________________________________________________________________________\n\n</value></part><part><name index=\"3\"/><value> Calls custom .dll also known as [[Extensions|Extension]]. The name of the extension is the name of the extension .dll without \".dll\" part (or without \"_x64.dll\" part on 64-bit Arma). For example if the file is 'myExtension.dll' the name of the extension will be \"myExtension\". For 64-bit extensions, the name of the extension doesn't need to change and is still \"myExtension\". The game will automatically look for 'myExtension_x64.dll' when you use 64-bit Arma exe.\n&lt;br&gt;&lt;br&gt;\nThis command is blocking, meaning that the game will wait for the extension to return before continuing. This may cause FPS drop if extension is not optimised. If extension takes too long, consider making asynchronous extension, where the result of the work of the extension is collected in a separate call.\n&lt;br&gt;&lt;br&gt;\nCurrently there is no limit how much data you can send to the extension. However there is a limit on how much data you can return from extension in one call. The limit is known to the extension and is passed in &lt;tt&gt; int outputSize&lt;/tt&gt;. The limit may or may not change in the future and is currently 10240 bytes. It is up to extension designer to handle multipart results if returned data exceeds output limit.\n&lt;br&gt;&lt;br&gt;\nSince Arma 3 v1.67 it is possible to pass array of arguments to extensions. The array of arguments could be anything and all elements will be converted to strings, however you might want to only send simple types like [[Boolean]]s, [[String]]s, [[Number]]s and [[Array]]s of all of the above. There is currently a limit on how many arguments can be sent and it is 2048 (since Arma 3 v1.92; previous limit: 1024). However an argument could be an [[Array]] itself, in this case extension maker will have to provide additional methods for parsing such arguments.\n&lt;br&gt;&lt;br&gt;\nPossible error codes:\n* 101: SYNTAX_ERROR_WRONG_PARAMS_SIZE\n* 102: SYNTAX_ERROR_WRONG_PARAMS_TYPE\n* 201: PARAMS_ERROR_TOO_MANY_ARGS\n* 301: EXECUTION_WARNING_TAKES_TOO_LONG\nEach error will have entry in .rpt file with more details.&lt;br&gt;&lt;br&gt;\n\nThe extension execution timeout, after which &lt;tt&gt;301: EXECUTION_WARNING_TAKES_TOO_LONG&lt;/tt&gt; warning is issued, is hardcoded on clients and is 1000.0 milliseconds (1 second). On the server the default limit is also 1 second, however it is possible to set custom limit with &lt;tt&gt;callExtReportLimit&lt;/tt&gt; param (see [[server.cfg#Server_Options | Server Options]]).\n&lt;br&gt;&lt;br&gt;\nIf an extension with the given name can't be found (or it is found but doesn't implement the required interface properly / at all) the following error will be written into the RPT (In this example the given dll-name was \"MyExtension\"):\n&lt;code&gt;14:27:07 CallExtension 'MyExtension' could not be found&lt;/code&gt;\n&lt;br&gt;\nIf an extension is not whitelisted with BattlEye (see [[Extensions]] for more info) it will be blocked on clients running with enabled BattlEye protection. RPT message outputted however is a little obscure:\n&lt;code&gt;21:35:04 Call extension 'MyExtension' could not be loaded: Insufficient system resources exist to complete the requested service&lt;/code&gt;\n&lt;br&gt;\nSince Arma 3 v1.69, &lt;tt&gt;RVExtensionVersion&lt;/tt&gt; interface (see source code example below) has been added, which is called by the engine on extension load and expects extension version. This interface is designed to work with both, Linux and Windows. The max buffer size is 32 bytes. The version information will then appear in .[[rpt]] file like so:\n&lt;code&gt;19:06:36 CallExtension loaded: test_extension (.\\test_extension.dll) [1.0.0.1]&lt;/code&gt;\n&lt;br&gt;\nFor more information see [[Extensions]].\n&lt;br&gt;&lt;br&gt;\n&lt;u&gt;Linux specific&lt;/u&gt;&lt;br&gt;\nWhile on Windows the extension name is case-insensitive, on Linux the extension name is case-sensitive and should match the name of the .so file exactly (minus \".so\" part). Currently only 32-bit extensions are supported on Linux.&lt;br&gt;&lt;br&gt;\n\n<template lineStart=\"1\"><title>Important </title><part><name index=\"1\"/><value> If a user has anti-virus software running, this could cause brand new extension to stutter the game and return with &lt;tt&gt;EXECUTION_WARNING_TAKES_TOO_LONG&lt;/tt&gt; when executed for the first time, because of the AV software scanning. After the extension is whitelisted by AV this should go away until a new version of the extension is installed. Perhaps a dummy call to the extension on init should be considered as a feature of implementation to account for that</value></part></template>\n&lt;br&gt;\n\n'''&lt;u&gt;Extension Callback&lt;/u&gt;'''\n\nSince Arma 3 v1.95 it is possible to call the game directly from the extension via function pointer provided when extension is called for the first time (assuming the extension implements at least one of the &lt;tt&gt;RVExtension&lt;/tt&gt; or &lt;tt&gt;RVExtensionArgs&lt;/tt&gt; methods). The function pointer passed over to &lt;tt&gt;RVExtensionRegisterCallback&lt;/tt&gt; method is of the following signature (see Example 4):\n<ext><name>syntaxhighlight</name><attr> lang=cpp</attr><inner>int(*callbackProc)(char const *name, char const *function, char const *data)</inner><close>&lt;/syntaxhighlight&gt;</close></ext>\nCalling this function pointer from extension will trigger [[Arma_3:_Event_Handlers/addMissionEventHandler#ExtensionCallback | \"ExtensionCallback\"]] mission event handler with 3 user supplied params. The params are\n* &lt;tt&gt;name&lt;/tt&gt; - make it unique name, for example the extension name, so that other modders can quickly filter out calls from own extensions\n* &lt;tt&gt;function&lt;/tt&gt; - make it name of the function the extension sends the result to. (Note: The returned function is just a STRING! So [[compile]] is needed, before using [[call]] or [[spawn]], to execute it)\n* &lt;tt&gt;data&lt;/tt&gt; - make it the actual result. You can also format it as an array so it could be parsed by [[parseSimpleArray]]\nCalling function pointer returns an &lt;tt&gt;int&lt;/tt&gt;. This is the number of available slots in the input buffer left for this frame after your call and can range from 99 to -1. The buffer is processed and cleared every frame and the maximum number of slots that can be filled per frame is 100. If you are planning to call back with more than 100 results per frame, make sure your extension retries if it receives negative &lt;tt&gt;int&lt;/tt&gt;, which means the buffer was full and your call did not succeed. Ideally suited for callbacks from different threads, but if callback is initiated from the calling thread, the EH will fire on the next frame of game simulation. Needless to say, the \"ExtensionCallback\" event handler needs to exist before any callbacks, otherwise the data will just stay in the buffer. Removing all \"ExtensionCallback\" EHs clears the buffer as well as mission restart. </value></part><part><name>DESCRIPTION</name>=<value>\n____________________________________________________________________________________________\n\n</value></part><part><name index=\"4\"/><value> extension '''callExtension''' function </value></part><part><name>SYNTAX1</name>=<value>\n\n</value></part><part><name>p1</name>=<value> extension: [[String]] - extension name </value></part><part><name>PARAMETER1</name>=<value>\n</value></part><part><name>p2</name>=<value> function: [[String]] - data sent to the extension </value></part><part><name>PARAMETER2</name>=<value>\n\n</value></part><part><name index=\"5\"/><value> [[String]] - data sent back from extension; If the extensiion wasn't found an empty String will be returned </value></part><part><name>RETURNVALUE1</name>=<value>\n\n</value></part><part><name> s2</name>=<value> extension '''callExtension''' [function, arguments]  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (''Since Arma 3 v1.67'') </value></part><part><name>SYNTAX2</name>=<value>\n\n</value></part><part><name>p21</name>=<value> extension: [[String]] - extension name </value></part><part><name>PARAMETER21</name>=<value>\n</value></part><part><name>p22</name>=<value> [function, arguments]: [[Array]] - callExtension params </value></part><part><name>PARAMETER22</name>=<value>\n</value></part><part><name>p23</name>=<value> function: [[String]] - extension function identifier </value></part><part><name>PARAMETER23</name>=<value>\n</value></part><part><name>p24</name>=<value> arguments: [[Array]] - function arguments. Could be array of [[Anything]], each element will be converted to [[String]] automatically. Current allowed max length of this array is 2048 (since Arma 3 v1.92; previous limit: 1024) </value></part><part><name>PARAMETER24</name>=<value>\n\n</value></part><part><name> r2</name>=<value> [[Array]] -  in format [result, returnCode, errorCode], where:\n* result: [[String]] - data sent back from extension. It is up to extension maker what it is.\n* returnCode: [[Number]] - integer return from extension method. It is up to extension maker to define it.\n* errorCode: [[Number]] - error code in case of command error (see description). 0 means no errors.</value></part><part><name>RETURNVALUE2</name>=<value>\n____________________________________________________________________________________________\n\n</value></part><part><name>x1</name>=<value> &lt;code&gt;_return = \"myExtension\" [[callExtension]] \"stringToBeParsed\";&lt;/code&gt;</value></part><part><name>EXAMPLE1</name>=<value> \n\n</value></part><part><name>x2</name>=<value> &lt;code&gt;_result = \"test_extension\" [[callExtension]] [[str]] [[weapons]] [[player]];\n_result = \"test_extension\" [[callExtension]] [\"fnc1\", [[getUnitLoadout]] [[player]]];\n_result = \"test_extension\" [[callExtension]] [\"fnc2\", [[magazinesAmmoFull]] [[player]]];\n_result = \"test_extension\" [[callExtension]] [\"fnc1\", [<ext><name>nowiki</name><attr/></ext>[[weapons]] [[player]], [[magazines]] [[player]]]];&lt;/code&gt;</value></part><part><name>EXAMPLE2</name>=<value>\n\n</value></part><part><name>x3</name>=<value> &lt;code&gt;_result = \"test_extension\" [[callExtension]] [\"fnc1\", [1,\"two\",[[true]],[4,\"five\",[[false]]]]];\n[[parseSimpleArray]] (_result [[select]] 0) [[params]] [\"_number\",\"_string\",\"_boolean\",\"_array\"];\n[[systemChat]] [[str]] [_number,_string,_boolean,_array];&lt;/code&gt;\n&lt;br&gt;\n&lt;u&gt;Source Code&lt;/u&gt; ([http://data.bistudio.com/a3data/test_extension.zip Download .dll])&lt;br&gt;&lt;br&gt;\nThis is an example of an extension compatible with both syntaxes. When using 1st syntax, the data is just copied from input to output. When using alt syntax, the arguments are parsed and then assembled back into string array in 2 ways: fnc1 and fnc2. fnc1 is a fraction faster.\n<ext><name>syntaxhighlight</name><attr> lang=cpp</attr><inner>\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n#include &lt;sstream&gt;\n\n#define CURRENT_VERSION \"1.0.0.1\"\n\nextern \"C\"\n{\n\t//--- Engine called on extension load \n\t__declspec (dllexport) void __stdcall RVExtensionVersion(char *output, int outputSize);\n\t//--- STRING callExtension STRING\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n\t//--- STRING callExtension ARRAY\n\t__declspec (dllexport) int __stdcall RVExtensionArgs(char *output, int outputSize, const char *function, const char **args, int argsCnt);\n}\n\n//--- Extension version information shown in .rpt file\nvoid __stdcall RVExtensionVersion(char *output, int outputSize)\n{\n\t//--- max outputSize is 32 bytes\n\tstrncpy_s(output, outputSize, CURRENT_VERSION, _TRUNCATE);\n}\n\n//--- name callExtension function\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\tstd::string str = function;\n\tstrncpy_s(output, outputSize, (\"Input Was: \" + str).c_str(), _TRUNCATE);\n}\n\n//--- name callExtension [function, args]\nint __stdcall RVExtensionArgs(char *output, int outputSize, const char *function, const char **args, int argsCnt)\n{\n\tif (strcmp(function, \"fnc1\") == 0)\n\t{\n\t\t//--- Manually assemble output array\n\t\tint i = 0;\n\t\tstd::string str = \"[\";\n\n\t\t//--- Each argument can be accessed via args[n]\n\t\tif (argsCnt &gt; 0)\n\t\t\tstr += args[i++];\n\n\t\twhile (i &lt; argsCnt)\n\t\t{\n\t\t\tstr += \",\";\n\t\t\tstr += args[i++];\n\t\t}\n\n\t\tstr += \"]\";\n\n\t\t//--- Extension result\n\t\tstrncpy_s(output, outputSize, str.c_str(), _TRUNCATE);\n\n\t\t//--- Extension return code\n\t\treturn 100;\n\t}\n\n\telse if (strcmp(function, \"fnc2\") == 0)\n\t{\n\t\t//--- Parse args into vector\n\t\tstd::vector&lt;std::string&gt; vec(args, std::next(args, argsCnt));\n\n\t\tstd::ostringstream oss;\n\t\tif (!vec.empty())\n\t\t{\n\t\t\t//--- Assemble output array\n\t\t\tstd::copy(vec.begin(), vec.end() - 1, std::ostream_iterator&lt;std::string&gt;(oss, \",\"));\n\t\t\toss &lt;&lt; vec.back();\n\t\t}\n\n\t\t//--- Extension result\n\t\tstrncpy_s(output, outputSize, (\"[\" + oss.str() + \"]\").c_str(), _TRUNCATE);\n\n\t\t//--- Extension return code\n\t\treturn 200;\n\t}\n\n\telse\n\t{\n\t\tstrncpy_s(output, outputSize, \"Avaliable Functions: fnc1, fnc2\", outputSize - 1);\n\t\treturn -1;\n\t}\n}\n</inner><close>&lt;/syntaxhighlight&gt;</close></ext></value></part><part><name>EXAMPLE3</name>=<value>\n\n</value></part><part><name>x4</name>=<value> &lt;code&gt;fncToExecute_1 = { [[hint]] [[format]] [\"Extension Result 1: %1\", [[_this]]] };\nfncToExecute_2 = { [[hint]] [[format]] [\"Extension Result 2: %1\", [[_this]]] };\nfncToExecute_3 = { [[hint]] [[format]] [\"Extension Result 3: %1\", [[_this]]] };\n\n[[addMissionEventHandler]] [\"ExtensionCallback\", \n{\n\t[[params]] [\"_name\", \"_function\", \"_data\"];\n\t[[if]] (_name [[isEqualTo]] \"test_callback\") [[then]] \n\t{ \n\t\t[[parseSimpleArray]] _data [[call]] ([[missionNamespace]] [[getVariable]] [_function, \n\t\t{ \n\t\t\t[[hint]] \"Function does not exist!\"\n\t\t}]); \n\t};\n}];\n\n\"test_callback\" [[callExtension]] [[str]] \"test data\";&lt;/code&gt;\n&lt;br&gt;\nHere is a minimal example of an extension utilising [[Arma_3:_Event_Handlers/addMissionEventHandler#ExtensionCallback | extension callback]] (don't actually do it like this). ''fncToExecute_X'' function is called from \"ExtensionCallback\" event handler when it is triggered after 2 seconds of the extension call.\n<ext><name>syntaxhighlight</name><attr> lang=cpp</attr><inner>\n#include &lt;thread&gt;\n#include &lt;string&gt;\n#include &lt;chrono&gt;\n\nextern \"C\"\n{\n\t__declspec (dllexport) void __stdcall RVExtensionRegisterCallback(int(*callbackProc)(char const *name, char const *function, char const *data));\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n}\n\nint(*callbackPtr)(char const *name, char const *function, char const *data) = nullptr;\n\nvoid __stdcall RVExtensionRegisterCallback(int(*callbackProc)(char const *name, char const *function, char const *data))\n{\n\tcallbackPtr = callbackProc;\n}\n\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\tif (!callbackPtr)\n\t\treturn;\n\n\tstd::thread ([](std::string fnc)\n\t{\t\t\n\t\tusing namespace std::chrono_literals;\n\t\tfnc = \"[1,2,3,\" + fnc + \"]\";\n\n\t\tfor (int i = 1; i &lt; 4; ++i) // run 3 times\n\t\t{\n\t\t\tstd::this_thread::sleep_for(2s); // sleep for 2 seconds\n\t\t\tcallbackPtr(\"test_callback\", (\"fncToExecute_\" + std::to_string(i)).c_str(), fnc.c_str());\n\t\t}\n\n\t}, function).detach();\n}\n</inner><close>&lt;/syntaxhighlight&gt;</close></ext></value></part><part><name>EXAMPLE4</name>=<value>\n____________________________________________________________________________________________\n\n</value></part><part><name index=\"6\"/><value> [[call]], [[compile]], [[parseSimpleArray]], [[Extensions]] </value></part><part><name>SEEALSO</name>=<value> \n\n</value></part><part><name index=\"7\"/><value>  </value></part><part><name>MPBEHAVIOUR</name>=<value> \n____________________________________________________________________________________________\n\n</value></part></template>\n\n&lt;h3 style='display:none'&gt;Notes&lt;/h3&gt;\n&lt;dl class='command_description'&gt;\n<comment>&lt;!-- Note Section BEGIN --&gt;\n</comment>\n<comment>&lt;!-- Note Section END --&gt;\n</comment>&lt;/dl&gt;\n\n&lt;h3 style='display:none'&gt;Bottom Section&lt;/h3&gt;\n\n[[Category:Scripting Commands|<template><title>uc:<template><title>PAGENAME</title></template></title></template>]]\n[[Category:Scripting Commands Arma 2|<template><title>uc:<template><title>PAGENAME</title></template></title></template>]]\n[[Category:Scripting Commands Arma 3|<template><title>uc:<template><title>PAGENAME</title></template></title></template>]]\n[[Category:Scripting Commands Take On Helicopters|<template><title>uc:<template><title>PAGENAME</title></template></title></template>]]\n[[Category:Arma 2: Operation Arrowhead: New Scripting Commands List|<template><title>uc:<template><title>PAGENAME</title></template></title></template>]]</root>"}}}